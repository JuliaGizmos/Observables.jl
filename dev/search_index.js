var documenterSearchIndex = {"docs":
[{"location":"#Observables","page":"Home","title":"Observables","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Observables are like Refs:","category":"page"},{"location":"","page":"Home","title":"Home","text":"using Observables\n\nobservable = Observable(0)\n\nobservable[]","category":"page"},{"location":"","page":"Home","title":"Home","text":"But unlike Refs, you can listen for changes:","category":"page"},{"location":"","page":"Home","title":"Home","text":"obs_func = on(observable) do val\n    println(\"Got an update: \", val)\nend\n\nobservable[] = 42","category":"page"},{"location":"","page":"Home","title":"Home","text":"To remove a handler use off with the return value of on:","category":"page"},{"location":"","page":"Home","title":"Home","text":"off(obs_func)","category":"page"},{"location":"#Weak-Connections","page":"Home","title":"Weak Connections","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"If you use on with weak = true, the connection will be removed when the return value of on is garbage collected. This can make it easier to clean up connections that are not used anymore.","category":"page"},{"location":"","page":"Home","title":"Home","text":"obs_func = on(observable, weak = true) do val\n    println(\"Got an update: \", val)\nend\n# as long as obs_func is reachable the connection will stay\n\nobs_func = nothing\n# now garbage collection can at any time clear the connection","category":"page"},{"location":"#Priority","page":"Home","title":"Priority","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"One can also give the callback a priority, to enable always calling a specific callback before/after others, independent of the order of registration. So one can do:","category":"page"},{"location":"","page":"Home","title":"Home","text":"obs = Observable(0)\non(obs; priority=-1) do x\n    println(\"Hi from first added\")\nend\non(obs) do x\n    println(\"Hi from second added\")\nend\nobs[] = 2\nHi from second added\nHi from first added","category":"page"},{"location":"","page":"Home","title":"Home","text":"Without the priority, the printing order would be the other way around. One can also return Consume(true/false), to consume an event and stop any later callback from getting called.","category":"page"},{"location":"","page":"Home","title":"Home","text":"obs = Observable(0)\non(obs) do x\n    if x == 1\n        println(\"stop calling callbacks after me!\")\n        return Consume(true)\n    else\n        println(\"Do not consume!\")\n    end\nend\non(obs) do x\n    println(\"I get called\")\nend\nobs[] = 2\nDo not consume!\nI get called\nobs[] = 1\nstop calling callbacks after me!","category":"page"},{"location":"","page":"Home","title":"Home","text":"The first one could of course also be written as:","category":"page"},{"location":"","page":"Home","title":"Home","text":"on(obs) do x\n    return Consume(x == 1)\nend","category":"page"},{"location":"#How-is-it-different-from-Reactive.jl?","page":"Home","title":"How is it different from Reactive.jl?","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"The main difference is Signals are manipulated mostly by converting one signal to another. For example, with signals, you can construct a changing UI by creating a Signal of UI objects and rendering them as the signal changes. On the other hand, you can use an Observable both as an input and an output. You can arbitrarily attach outputs to inputs allowing structuring code in a signals-and-slots kind of pattern.","category":"page"},{"location":"","page":"Home","title":"Home","text":"Another difference is Observables are synchronous, Signals are asynchronous. Observables may be better suited for an imperative style of programming.","category":"page"},{"location":"#API","page":"Home","title":"API","text":"","category":"section"},{"location":"#Public","page":"Home","title":"Public","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Modules = [Observables]\nPrivate = false","category":"page"},{"location":"#Observables.Observable","page":"Home","title":"Observables.Observable","text":"obs = Observable(val; ignore_equal_values=false)\nobs = Observable{T}(val; ignore_equal_values=false)\n\nLike a Ref, but updates can be watched by adding a handler using on or map. Set ignore_equal_values=true to not trigger an event for observable[] = new_value if isequal(observable[], new_value).\n\n\n\n\n\n","category":"type"},{"location":"#Observables.ObserverFunction","page":"Home","title":"Observables.ObserverFunction","text":"mutable struct ObserverFunction <: Function\n\nFields:\n\nf::Function\nobservable::AbstractObservable\nweak::Bool\n\nObserverFunction is intended as the return value for on because we can remove the created closure from obsfunc.observable's listener vectors when ObserverFunction goes out of scope - as long as the weak flag is set. If the weak flag is not set, nothing happens when the ObserverFunction goes out of scope and it can be safely ignored. It can still be useful because it is easier to call off(obsfunc) instead of off(observable, f) to release the connection later.\n\n\n\n\n\n","category":"type"},{"location":"#Observables.async_latest-Union{Tuple{AbstractObservable{T}}, Tuple{T}, Tuple{AbstractObservable{T}, Any}} where T","page":"Home","title":"Observables.async_latest","text":"async_latest(observable::AbstractObservable, n=1)\n\nReturns an Observable which drops all but the last n updates to observable if processing the updates takes longer than the interval between updates.\n\nThis is useful if you want to pass the updates from, say, a slider to a plotting function that takes a while to compute. The plot will directly compute the last frame skipping the intermediate ones.\n\nExample:\n\nobservable = Observable(0)\nfunction compute_something(x)\n    for i=1:10^8 rand() end # simulate something expensive\n    println(\"updated with $x\")\nend\no_latest = async_latest(observable, 1)\non(compute_something, o_latest) # compute something on the latest update\n\nfor i=1:5\n    observable[] = i\nend\n\n\n\n\n\n","category":"method"},{"location":"#Observables.connect!-Tuple{AbstractObservable, AbstractObservable}","page":"Home","title":"Observables.connect!","text":"connect!(o1::AbstractObservable, o2::AbstractObservable)\n\nForwards all updates from o2 to o1.\n\nSee also Observables.ObservablePair.\n\n\n\n\n\n","category":"method"},{"location":"#Observables.obsid-Tuple{Observable}","page":"Home","title":"Observables.obsid","text":"obsid(observable::Observable)\n\nGets a unique id for an observable.\n\n\n\n\n\n","category":"method"},{"location":"#Observables.off-Tuple{AbstractObservable, Any}","page":"Home","title":"Observables.off","text":"off(observable::AbstractObservable, f)\n\nRemoves f from listeners of observable.\n\nReturns true if f could be removed, otherwise false.\n\n\n\n\n\n","category":"method"},{"location":"#Observables.off-Tuple{ObserverFunction}","page":"Home","title":"Observables.off","text":"off(obsfunc::ObserverFunction)\n\nRemove the listener function obsfunc.f from the listeners of obsfunc.observable. Once obsfunc goes out of scope, this should allow obsfunc.f and all the values it might have closed over to be garbage collected (unless there are other references to it).\n\n\n\n\n\n","category":"method"},{"location":"#Observables.on-Tuple{Any, AbstractObservable}","page":"Home","title":"Observables.on","text":"on(f, observable::AbstractObservable; weak = false, priority=0, update=false)::ObserverFunction\n\nAdds function f as listener to observable. Whenever observable's value is set via observable[] = val, f is called with val.\n\nReturns an ObserverFunction that wraps f and observable and allows to disconnect easily by calling off(observerfunction) instead of off(f, observable). If instead you want to compute a new Observable from an old one, use map(f, ::Observable).\n\nIf weak = true is set, the new connection will be removed as soon as the returned ObserverFunction is not referenced anywhere and is garbage collected. This is useful if some parent object makes connections to outside observables and stores the resulting ObserverFunction instances. Then, once that parent object is garbage collected, the weak observable connections are removed automatically.\n\nExample\n\njulia> obs = Observable(0)\nObservable(0)\n\njulia> on(obs) do val\n           println(\"current value is \", val)\n       end\nObserverFunction defined at REPL[17]:2 operating on Observable(0)\njulia> obs[] = 5;\ncurrent value is 5\n\nOne can also give the callback a priority, to enable always calling a specific callback before/after others, independent of the order of registration. The callback with the highest priority gets called first, the default is zero, and the whole range of Int can be used. So one can do:\n\njulia> obs = Observable(0)\njulia> on(obs; priority=-1) do x\n           println(\"Hi from first added\")\n       end\njulia> on(obs) do x\n           println(\"Hi from second added\")\n       end\njulia> obs[] = 2\nHi from second added\nHi from first added\n\nIf you set update=true, on will call f(obs[]) immediately:\n\njulia> on(Observable(1); update=true) do x\n    println(\"hi\")\nend\nhi\n\n\n\n\n\n","category":"method"},{"location":"#Observables.onany-Tuple{Any, Vararg{Any}}","page":"Home","title":"Observables.onany","text":"onany(f, args...; weak::Bool = false, priority::Int = 0, update::Bool = false)\n\nCalls f on updates to any observable refs in args. args may contain any number of Observable objects. f will be passed the values contained in the refs as the respective argument. All other objects in args are passed as-is.\n\nSee also: on.\n\n\n\n\n\n","category":"method"},{"location":"#Observables.throttle-Union{Tuple{T}, Tuple{Any, AbstractObservable{T}}} where T","page":"Home","title":"Observables.throttle","text":"throttle(dt, input::AbstractObservable)\n\nThrottle a signal to update at most once every dt seconds. The throttled signal holds the last update of the input signal during each dt second time window.\n\n\n\n\n\n","category":"method"},{"location":"#Extensions-of-Base-methods-or-internal-methods","page":"Home","title":"Extensions of Base methods or internal methods","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Modules = [Observables]\nPublic = false","category":"page"},{"location":"#Observables.ObservablePair","page":"Home","title":"Observables.ObservablePair","text":"ObservablePair(first, second)\n\nTwo observables trigger each other, but only in one direction as otherwise there will be an infinite loop of updates\n\n\n\n\n\n","category":"type"},{"location":"#Base.getindex-Tuple{Observable}","page":"Home","title":"Base.getindex","text":"observable[]\n\nReturns the current value of observable.\n\n\n\n\n\n","category":"method"},{"location":"#Base.map!-Tuple{Any, AbstractObservable, Vararg{Any}}","page":"Home","title":"Base.map!","text":"map!(f, result::AbstractObservable, args...; update::Bool=true)\n\nUpdates result with the result of calling f with values extracted from args. args may contain any number of Observable objects. f will be passed the values contained in the refs as the respective argument. All other objects in args are passed as-is.\n\nBy default result gets updated immediately, but this can be suppressed by specifying update=false.\n\nExample\n\nWe'll create an observable that can hold an arbitrary number:\n\njulia> obs = Observable{Number}(3)\nObservable{Number}(3)\n\nNow,\n\njulia> obsrt1 = map(sqrt, obs)\nObservable(1.7320508075688772)\n\ncreates an Observable{Float64}, which will fail to update if we set obs[] = 3+4im. However,\n\njulia> obsrt2 = map!(sqrt, Observable{Number}(), obs)\nObservable{Number}(1.7320508075688772)\n\ncan handle any number type for which sqrt is defined.\n\n\n\n\n\n","category":"method"},{"location":"#Base.map-Union{Tuple{F}, Tuple{F, AbstractObservable, Vararg{Any}}} where F","page":"Home","title":"Base.map","text":"obs = map(f, arg1::AbstractObservable, args...; ignore_equal_values=false)\n\nCreates a new observable obs which contains the result of f applied to values extracted from arg1 and args (i.e., f(arg1[], ...). arg1 must be an observable for dispatch reasons. args may contain any number of Observable objects. f will be passed the values contained in the observables as the respective argument. All other objects in args are passed as-is.\n\nIf you don't need the value of obs, and just want to run f whenever the arguments update, use on or onany instead.\n\nExample\n\njulia> obs = Observable([1,2,3]);\n\njulia> map(length, obs)\nObservable(3)\n\n\n\n\n\n","category":"method"},{"location":"#Base.notify-Tuple{AbstractObservable}","page":"Home","title":"Base.notify","text":"notify(observable::AbstractObservable)\n\nUpdate all listeners of observable. Returns true if an event got consumed before notifying every listener.\n\n\n\n\n\n","category":"method"},{"location":"#Base.setindex!-Tuple{Observable, Any}","page":"Home","title":"Base.setindex!","text":"observable[] = val\n\nUpdates the value of an Observable to val and call its listeners.\n\n\n\n\n\n","category":"method"},{"location":"#Observables.clear-Tuple{Observable}","page":"Home","title":"Observables.clear","text":"clear(obs::Observable)\n\nEmpties all listeners and clears all inputs, removing the observable from all interactions with it's parent.\n\n\n\n\n\n","category":"method"},{"location":"#Observables.to_value-Tuple{Any}","page":"Home","title":"Observables.to_value","text":"to_value(x::Union{Any, AbstractObservable})\n\nExtracts the value of an observable, and returns the object if it's not an observable!\n\n\n\n\n\n","category":"method"},{"location":"#Observables.@map!-Tuple{Any, Any}","page":"Home","title":"Observables.@map!","text":"@map!(d, expr)\n\nWrap AbstractObservables in & to compute expression expr using their value: the expression will be computed every time the AbstractObservables are updated and d will be set to match that value.\n\nExamples\n\njulia> a = Observable(2);\n\njulia> b = Observable(3);\n\njulia> c = Observable(10);\n\njulia> Observables.@map! c &a + &b;\n\njulia> c[]\n10\n\njulia> a[] = 100\n100\n\njulia> c[]\n103\n\n\n\n\n\n","category":"macro"},{"location":"#Observables.@map-Tuple{Any}","page":"Home","title":"Observables.@map","text":"@map(expr)\n\nWrap AbstractObservables in & to compute expression expr using their value. The expression will be computed when @map is called and  every time the AbstractObservables are updated.\n\nExamples\n\njulia> a = Observable(2);\n\njulia> b = Observable(3);\n\njulia> c = Observables.@map &a + &b;\n\njulia> c[]\n5\n\njulia> a[] = 100\n100\n\njulia> c[]\n103\n\n\n\n\n\n","category":"macro"},{"location":"#Observables.@on-Tuple{Any}","page":"Home","title":"Observables.@on","text":"@on(expr)\n\nWrap AbstractObservables in & to execute expression expr using their value. The expression will be computed every time the AbstractObservables are updated.\n\nExamples\n\njulia> a = Observable(2);\n\njulia> b = Observable(3);\n\njulia> Observables.@on println(\"The sum of a+b is $(&a + &b)\");\n\njulia> a[] = 100;\nThe sum of a+b is 103\n\n\n\n\n\n","category":"macro"}]
}
