<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Home · Observables.jl</title><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.11.1/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="assets/documenter.js"></script><script src="siteinfo.js"></script><script src="../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/documenter-dark.css" data-theme-name="documenter-dark"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit">Observables.jl</span></div><form class="docs-search" action="search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li class="is-active"><a class="tocitem" href>Home</a><ul class="internal"><li><a class="tocitem" href="#API"><span>API</span></a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Home</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Home</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/JuliaGizmos/Observables.jl/blob/master/docs/src/index.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="Observables"><a class="docs-heading-anchor" href="#Observables">Observables</a><a id="Observables-1"></a><a class="docs-heading-anchor-permalink" href="#Observables" title="Permalink"></a></h1><p>Observables are like <code>Ref</code>s:</p><pre><code class="language-julia-repl">julia&gt; using Observables

julia&gt; observable = Observable(0)
Observable(0)

julia&gt; observable[]
0</code></pre><p>But unlike <code>Ref</code>s, you can listen for changes:</p><pre><code class="language-julia-repl">julia&gt; obs_func = on(observable) do val
           println(&quot;Got an update: &quot;, val)
       end
ObserverFunction defined at none:2 operating on Observable(0)

julia&gt; observable[] = 42
Got an update: 42
42</code></pre><p>To remove a handler use <code>off</code> with the return value of <code>on</code>:</p><pre><code class="language-julia-repl">julia&gt; off(obs_func)
true</code></pre><h3 id="Weak-Connections"><a class="docs-heading-anchor" href="#Weak-Connections">Weak Connections</a><a id="Weak-Connections-1"></a><a class="docs-heading-anchor-permalink" href="#Weak-Connections" title="Permalink"></a></h3><p>If you use <code>on</code> with <code>weak = true</code>, the connection will be removed when the return value of <code>on</code> is garbage collected. This can make it easier to clean up connections that are not used anymore.</p><pre><code class="language-julia">obs_func = on(observable, weak = true) do val
    println(&quot;Got an update: &quot;, val)
end
# as long as obs_func is reachable the connection will stay

obs_func = nothing
# now garbage collection can at any time clear the connection</code></pre><h3 id="Priority"><a class="docs-heading-anchor" href="#Priority">Priority</a><a id="Priority-1"></a><a class="docs-heading-anchor-permalink" href="#Priority" title="Permalink"></a></h3><p>One can also give the callback a priority, to enable always calling a specific callback before/after others, independent of the order of registration. So one can do:</p><pre><code class="language-julia">obs = Observable(0)
on(obs; priority=-1) do x
    println(&quot;Hi from first added&quot;)
end
on(obs) do x
    println(&quot;Hi from second added&quot;)
end
obs[] = 2
Hi from second added
Hi from first added</code></pre><p>Without the priority, the printing order would be the other way around. One can also return <code>Consume(true/false)</code>, to consume an event and stop any later callback from getting called.</p><pre><code class="language-julia">obs = Observable(0)
on(obs) do x
    if x == 1
        println(&quot;stop calling callbacks after me!&quot;)
        return Consume(true)
    else
        println(&quot;Do not consume!&quot;)
    end
end
on(obs) do x
    println(&quot;I get called&quot;)
end
obs[] = 2
Do not consume!
I get called
obs[] = 1
stop calling callbacks after me!</code></pre><p>The first one could of course also be written as:</p><pre><code class="language-julia">on(obs) do x
    return Consume(x == 1)
end</code></pre><h3 id="How-is-it-different-from-Reactive.jl?"><a class="docs-heading-anchor" href="#How-is-it-different-from-Reactive.jl?">How is it different from Reactive.jl?</a><a id="How-is-it-different-from-Reactive.jl?-1"></a><a class="docs-heading-anchor-permalink" href="#How-is-it-different-from-Reactive.jl?" title="Permalink"></a></h3><p>The main difference is <code>Signal</code>s are manipulated mostly by converting one signal to another. For example, with signals, you can construct a changing UI by creating a <code>Signal</code> of UI objects and rendering them as the signal changes. On the other hand, you can use an Observable both as an input and an output. You can arbitrarily attach outputs to inputs allowing structuring code in a <a href="http://doc.qt.io/qt-4.8/signalsandslots.html">signals-and-slots</a> kind of pattern.</p><p>Another difference is Observables are synchronous, Signals are asynchronous. Observables may be better suited for an imperative style of programming.</p><h2 id="API"><a class="docs-heading-anchor" href="#API">API</a><a id="API-1"></a><a class="docs-heading-anchor-permalink" href="#API" title="Permalink"></a></h2><h3 id="Public"><a class="docs-heading-anchor" href="#Public">Public</a><a id="Public-1"></a><a class="docs-heading-anchor-permalink" href="#Public" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-binding" id="Observables.Observable" href="#Observables.Observable"><code>Observables.Observable</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">obs = Observable(val; ignore_equal_values=false)
obs = Observable{T}(val; ignore_equal_values=false)</code></pre><p>Like a <code>Ref</code>, but updates can be watched by adding a handler using <a href="#Observables.on-Tuple{Any, AbstractObservable}"><code>on</code></a> or <a href="#Base.map-Union{Tuple{F}, Tuple{F, AbstractObservable, Vararg{Any}}} where F"><code>map</code></a>. Set <code>ignore_equal_values=true</code> to not trigger an event for <code>observable[] = new_value</code> if <code>isequal(observable[], new_value)</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGizmos/Observables.jl/blob/f114706d920c736f8dd75bcb029e1f2d4df1d661/src/Observables.jl#L59-L65">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Observables.ObserverFunction" href="#Observables.ObserverFunction"><code>Observables.ObserverFunction</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">mutable struct ObserverFunction &lt;: Function</code></pre><p>Fields:</p><pre><code class="language-none">f::Function
observable::AbstractObservable
weak::Bool</code></pre><p><code>ObserverFunction</code> is intended as the return value for <code>on</code> because we can remove the created closure from <code>obsfunc.observable</code>&#39;s listener vectors when ObserverFunction goes out of scope - as long as the <code>weak</code> flag is set. If the <code>weak</code> flag is not set, nothing happens when the ObserverFunction goes out of scope and it can be safely ignored. It can still be useful because it is easier to call <code>off(obsfunc)</code> instead of <code>off(observable, f)</code> to release the connection later.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGizmos/Observables.jl/blob/f114706d920c736f8dd75bcb029e1f2d4df1d661/src/Observables.jl#L25-L41">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Observables.async_latest-Union{Tuple{AbstractObservable{T}}, Tuple{T}, Tuple{AbstractObservable{T}, Any}} where T" href="#Observables.async_latest-Union{Tuple{AbstractObservable{T}}, Tuple{T}, Tuple{AbstractObservable{T}, Any}} where T"><code>Observables.async_latest</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">async_latest(observable::AbstractObservable, n=1)</code></pre><p>Returns an <code>Observable</code> which drops all but the last <code>n</code> updates to <code>observable</code> if processing the updates takes longer than the interval between updates.</p><p>This is useful if you want to pass the updates from, say, a slider to a plotting function that takes a while to compute. The plot will directly compute the last frame skipping the intermediate ones.</p><p><strong>Example:</strong></p><pre><code class="language-none">observable = Observable(0)
function compute_something(x)
    for i=1:10^8 rand() end # simulate something expensive
    println(&quot;updated with $x&quot;)
end
o_latest = async_latest(observable, 1)
on(compute_something, o_latest) # compute something on the latest update

for i=1:5
    observable[] = i
end</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGizmos/Observables.jl/blob/f114706d920c736f8dd75bcb029e1f2d4df1d661/src/Observables.jl#L572-L598">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Observables.connect!-Tuple{AbstractObservable, AbstractObservable}" href="#Observables.connect!-Tuple{AbstractObservable, AbstractObservable}"><code>Observables.connect!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">connect!(o1::AbstractObservable, o2::AbstractObservable)</code></pre><p>Forwards all updates from <code>o2</code> to <code>o1</code>.</p><p>See also <a href="#Observables.ObservablePair"><code>Observables.ObservablePair</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGizmos/Observables.jl/blob/f114706d920c736f8dd75bcb029e1f2d4df1d661/src/Observables.jl#L534-L540">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Observables.obsid-Tuple{Observable}" href="#Observables.obsid-Tuple{Observable}"><code>Observables.obsid</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">obsid(observable::Observable)</code></pre><p>Gets a unique id for an observable.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGizmos/Observables.jl/blob/f114706d920c736f8dd75bcb029e1f2d4df1d661/src/Observables.jl#L80-L84">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Observables.off-Tuple{AbstractObservable, Any}" href="#Observables.off-Tuple{AbstractObservable, Any}"><code>Observables.off</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">off(observable::AbstractObservable, f)</code></pre><p>Removes <code>f</code> from listeners of <code>observable</code>.</p><p>Returns <code>true</code> if <code>f</code> could be removed, otherwise <code>false</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGizmos/Observables.jl/blob/f114706d920c736f8dd75bcb029e1f2d4df1d661/src/Observables.jl#L372-L378">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Observables.off-Tuple{ObserverFunction}" href="#Observables.off-Tuple{ObserverFunction}"><code>Observables.off</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">off(obsfunc::ObserverFunction)</code></pre><p>Remove the listener function <code>obsfunc.f</code> from the listeners of <code>obsfunc.observable</code>. Once <code>obsfunc</code> goes out of scope, this should allow <code>obsfunc.f</code> and all the values it might have closed over to be garbage collected (unless there are other references to it).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGizmos/Observables.jl/blob/f114706d920c736f8dd75bcb029e1f2d4df1d661/src/Observables.jl#L398-L405">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Observables.on-Tuple{Any, AbstractObservable}" href="#Observables.on-Tuple{Any, AbstractObservable}"><code>Observables.on</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">on(f, observable::AbstractObservable; weak = false, priority=0, update=false)::ObserverFunction</code></pre><p>Adds function <code>f</code> as listener to <code>observable</code>. Whenever <code>observable</code>&#39;s value is set via <code>observable[] = val</code>, <code>f</code> is called with <code>val</code>.</p><p>Returns an <a href="#Observables.ObserverFunction"><code>ObserverFunction</code></a> that wraps <code>f</code> and <code>observable</code> and allows to disconnect easily by calling <code>off(observerfunction)</code> instead of <code>off(f, observable)</code>. If instead you want to compute a new <code>Observable</code> from an old one, use <a href="#Base.map-Union{Tuple{F}, Tuple{F, AbstractObservable, Vararg{Any}}} where F"><code>map(f, ::Observable)</code></a>.</p><p>If <code>weak = true</code> is set, the new connection will be removed as soon as the returned <code>ObserverFunction</code> is not referenced anywhere and is garbage collected. This is useful if some parent object makes connections to outside observables and stores the resulting <code>ObserverFunction</code> instances. Then, once that parent object is garbage collected, the weak observable connections are removed automatically.</p><p><strong>Example</strong></p><pre><code class="language-julia">julia&gt; obs = Observable(0)
Observable(0)

julia&gt; on(obs) do val
           println(&quot;current value is &quot;, val)
       end
ObserverFunction defined at REPL[17]:2 operating on Observable(0)
julia&gt; obs[] = 5;
current value is 5</code></pre><p>One can also give the callback a priority, to enable always calling a specific callback before/after others, independent of the order of registration. The callback with the highest priority gets called first, the default is zero, and the whole range of Int can be used. So one can do:</p><pre><code class="language-julia">julia&gt; obs = Observable(0)
julia&gt; on(obs; priority=-1) do x
           println(&quot;Hi from first added&quot;)
       end
julia&gt; on(obs) do x
           println(&quot;Hi from second added&quot;)
       end
julia&gt; obs[] = 2
Hi from second added
Hi from first added</code></pre><p>If you set <code>update=true</code>, on will call f(obs[]) immediately:</p><pre><code class="language-julia">julia&gt; on(Observable(1); update=true) do x
    println(&quot;hi&quot;)
end
hi</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGizmos/Observables.jl/blob/f114706d920c736f8dd75bcb029e1f2d4df1d661/src/Observables.jl#L301-L356">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Observables.onany-Tuple{Any, Vararg{Any}}" href="#Observables.onany-Tuple{Any, Vararg{Any}}"><code>Observables.onany</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">onany(f, args...; weak::Bool = false, priority::Int = 0, update::Bool = false)</code></pre><p>Calls <code>f</code> on updates to any observable refs in <code>args</code>. <code>args</code> may contain any number of <code>Observable</code> objects. <code>f</code> will be passed the values contained in the refs as the respective argument. All other objects in <code>args</code> are passed as-is.</p><p>See also: <a href="#Observables.on-Tuple{Any, AbstractObservable}"><code>on</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGizmos/Observables.jl/blob/f114706d920c736f8dd75bcb029e1f2d4df1d661/src/Observables.jl#L455-L464">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Observables.throttle-Union{Tuple{T}, Tuple{Any, AbstractObservable{T}}} where T" href="#Observables.throttle-Union{Tuple{T}, Tuple{Any, AbstractObservable{T}}} where T"><code>Observables.throttle</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">throttle(dt, input::AbstractObservable)</code></pre><p>Throttle a signal to update at most once every <code>dt</code> seconds. The throttled signal holds the last update of the <code>input</code> signal during each <code>dt</code> second time window.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGizmos/Observables.jl/blob/f114706d920c736f8dd75bcb029e1f2d4df1d661/src/time.jl#L1-L6">source</a></section></article><h3 id="Extensions-of-Base-methods-or-internal-methods"><a class="docs-heading-anchor" href="#Extensions-of-Base-methods-or-internal-methods">Extensions of Base methods or internal methods</a><a id="Extensions-of-Base-methods-or-internal-methods-1"></a><a class="docs-heading-anchor-permalink" href="#Extensions-of-Base-methods-or-internal-methods" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-binding" id="Observables.ObservablePair" href="#Observables.ObservablePair"><code>Observables.ObservablePair</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">ObservablePair(first, second)</code></pre><p>Two observables trigger each other, but only in one direction as otherwise there will be an infinite loop of updates</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGizmos/Observables.jl/blob/f114706d920c736f8dd75bcb029e1f2d4df1d661/src/observablepair.jl#L1-L6">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.getindex-Tuple{Observable}" href="#Base.getindex-Tuple{Observable}"><code>Base.getindex</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">observable[]</code></pre><p>Returns the current value of <code>observable</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGizmos/Observables.jl/blob/f114706d920c736f8dd75bcb029e1f2d4df1d661/src/Observables.jl#L125-L129">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.map!-Tuple{Any, AbstractObservable, Vararg{Any}}" href="#Base.map!-Tuple{Any, AbstractObservable, Vararg{Any}}"><code>Base.map!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">map!(f, result::AbstractObservable, args...; update::Bool=true)</code></pre><p>Updates <code>result</code> with the result of calling <code>f</code> with values extracted from args. <code>args</code> may contain any number of <code>Observable</code> objects. <code>f</code> will be passed the values contained in the refs as the respective argument. All other objects in <code>args</code> are passed as-is.</p><p>By default <code>result</code> gets updated immediately, but this can be suppressed by specifying <code>update=false</code>.</p><p><strong>Example</strong></p><p>We&#39;ll create an observable that can hold an arbitrary number:</p><pre><code class="language-julia-repl">julia&gt; obs = Observable{Number}(3)
Observable{Number}(3)</code></pre><p>Now,</p><pre><code class="language-julia-repl">julia&gt; obsrt1 = map(sqrt, obs)
Observable(1.7320508075688772)</code></pre><p>creates an <code>Observable{Float64}</code>, which will fail to update if we set <code>obs[] = 3+4im</code>. However,</p><pre><code class="language-julia-repl">julia&gt; obsrt2 = map!(sqrt, Observable{Number}(), obs)
Observable{Number}(1.7320508075688772)</code></pre><p>can handle any number type for which <code>sqrt</code> is defined.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGizmos/Observables.jl/blob/f114706d920c736f8dd75bcb029e1f2d4df1d661/src/Observables.jl#L478-L513">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.map-Union{Tuple{F}, Tuple{F, AbstractObservable, Vararg{Any}}} where F" href="#Base.map-Union{Tuple{F}, Tuple{F, AbstractObservable, Vararg{Any}}} where F"><code>Base.map</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">obs = map(f, arg1::AbstractObservable, args...; ignore_equal_values=false)</code></pre><p>Creates a new observable <code>obs</code> which contains the result of <code>f</code> applied to values extracted from <code>arg1</code> and <code>args</code> (i.e., <code>f(arg1[], ...)</code>. <code>arg1</code> must be an observable for dispatch reasons. <code>args</code> may contain any number of <code>Observable</code> objects. <code>f</code> will be passed the values contained in the observables as the respective argument. All other objects in <code>args</code> are passed as-is.</p><p>If you don&#39;t need the value of <code>obs</code>, and just want to run <code>f</code> whenever the arguments update, use <a href="#Observables.on-Tuple{Any, AbstractObservable}"><code>on</code></a> or <a href="#Observables.onany-Tuple{Any, Vararg{Any}}"><code>onany</code></a> instead.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl">julia&gt; obs = Observable([1,2,3]);

julia&gt; map(length, obs)
Observable(3)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGizmos/Observables.jl/blob/f114706d920c736f8dd75bcb029e1f2d4df1d661/src/Observables.jl#L543-L563">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.notify-Tuple{AbstractObservable}" href="#Base.notify-Tuple{AbstractObservable}"><code>Base.notify</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">notify(observable::AbstractObservable)</code></pre><p>Update all listeners of <code>observable</code>. Returns true if an event got consumed before notifying every listener.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGizmos/Observables.jl/blob/f114706d920c736f8dd75bcb029e1f2d4df1d661/src/Observables.jl#L193-L198">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.setindex!-Tuple{Observable, Any}" href="#Base.setindex!-Tuple{Observable, Any}"><code>Base.setindex!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">observable[] = val</code></pre><p>Updates the value of an <code>Observable</code> to <code>val</code> and call its listeners.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGizmos/Observables.jl/blob/f114706d920c736f8dd75bcb029e1f2d4df1d661/src/Observables.jl#L109-L113">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Observables.clear-Tuple{Observable}" href="#Observables.clear-Tuple{Observable}"><code>Observables.clear</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">clear(obs::Observable)</code></pre><p>Empties all listeners and clears all inputs, removing the observable from all interactions with it&#39;s parent.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGizmos/Observables.jl/blob/f114706d920c736f8dd75bcb029e1f2d4df1d661/src/Observables.jl#L443-L447">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Observables.to_value-Tuple{Any}" href="#Observables.to_value-Tuple{Any}"><code>Observables.to_value</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">to_value(x::Union{Any, AbstractObservable})</code></pre><p>Extracts the value of an observable, and returns the object if it&#39;s not an observable!</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGizmos/Observables.jl/blob/f114706d920c736f8dd75bcb029e1f2d4df1d661/src/Observables.jl#L134-L137">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Observables.@map!-Tuple{Any, Any}" href="#Observables.@map!-Tuple{Any, Any}"><code>Observables.@map!</code></a> — <span class="docstring-category">Macro</span></header><section><div><pre><code class="language-julia">@map!(d, expr)</code></pre><p>Wrap <code>AbstractObservables</code> in <code>&amp;</code> to compute expression <code>expr</code> using their value: the expression will be computed every time the <code>AbstractObservables</code> are updated and <code>d</code> will be set to match that value.</p><p><strong>Examples</strong></p><pre><code class="language-none">julia&gt; a = Observable(2);

julia&gt; b = Observable(3);

julia&gt; c = Observable(10);

julia&gt; Observables.@map! c &amp;a + &amp;b;

julia&gt; c[]
10

julia&gt; a[] = 100
100

julia&gt; c[]
103</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGizmos/Observables.jl/blob/f114706d920c736f8dd75bcb029e1f2d4df1d661/src/macros.jl#L57-L83">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Observables.@map-Tuple{Any}" href="#Observables.@map-Tuple{Any}"><code>Observables.@map</code></a> — <span class="docstring-category">Macro</span></header><section><div><pre><code class="language-julia">@map(expr)</code></pre><p>Wrap <code>AbstractObservables</code> in <code>&amp;</code> to compute expression <code>expr</code> using their value. The expression will be computed when <code>@map</code> is called and  every time the <code>AbstractObservables</code> are updated.</p><p><strong>Examples</strong></p><pre><code class="language-none">julia&gt; a = Observable(2);

julia&gt; b = Observable(3);

julia&gt; c = Observables.@map &amp;a + &amp;b;

julia&gt; c[]
5

julia&gt; a[] = 100
100

julia&gt; c[]
103</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGizmos/Observables.jl/blob/f114706d920c736f8dd75bcb029e1f2d4df1d661/src/macros.jl#L23-L47">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Observables.@on-Tuple{Any}" href="#Observables.@on-Tuple{Any}"><code>Observables.@on</code></a> — <span class="docstring-category">Macro</span></header><section><div><pre><code class="language-julia">@on(expr)</code></pre><p>Wrap <code>AbstractObservables</code> in <code>&amp;</code> to execute expression <code>expr</code> using their value. The expression will be computed every time the <code>AbstractObservables</code> are updated.</p><p><strong>Examples</strong></p><pre><code class="language-none">julia&gt; a = Observable(2);

julia&gt; b = Observable(3);

julia&gt; Observables.@on println(&quot;The sum of a+b is $(&amp;a + &amp;b)&quot;);

julia&gt; a[] = 100;
The sum of a+b is 103</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGizmos/Observables.jl/blob/f114706d920c736f8dd75bcb029e1f2d4df1d661/src/macros.jl#L93-L111">source</a></section></article></article><nav class="docs-footer"><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> on <span class="colophon-date" title="Monday 6 November 2023 12:26">Monday 6 November 2023</span>. Using Julia version 1.9.3.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
